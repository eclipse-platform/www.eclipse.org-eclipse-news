<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                                                        
                                                                       
  <meta http-equiv="Content-Type" content="text/html; charset=charset=ISO-8859-1">
  <title>What the heck is a plug-in anyway?</title>
                                                                        
                                                                        
                                                                        
                                  
  <link rel="stylesheet" href="/default_style.css">
</head>
  <body link="#0000ff" vlink="#800080">
       
<p align="right"><img src="../../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></p>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
      <tbody>
        <tr>
          <td align="Left" valign="Top" colspan="2" bgcolor="#0080c0"><b><font face="Arial,Helvetica"><font color="#ffffff">
                                     Eclipse          Corner Article</font></font></b></td>
        </tr>
               
  </tbody>    
</table>
    
       
<div align="Left">    
<h1><img src="images/Idea.jpg" height="86" width="120" align="Center">
    </h1>
    </div>
       
<h1 align="Center">What the heck is a plug-in anyway? </h1>
       
<blockquote>            
  <p><b>Summary</b><br>
    <center><b>This is a draft document. </b></center><br>
    The Eclipse Platform is based on the notion of plug-ins. Plug-ins are a simple 
    but powerful mechanism that allow developers and users to construct complex 
    tool sets by composing functionality (i.e., plug-ins). There are of course 
    a number of subtleties in how plug-ins are defined and how they interact. 
    This article attempts to demystify plug-ins and make it easier to create and 
    manage Eclipse Platform configurations.</p>
  <p><b> By Debbie Wilson and Jeff McAffer, IBM OTI Labs</b><br>
    <font size="-1">April 22, 2003</font></p>
      </blockquote>
               
  <hr width="100%">            
  <h2>Why Plug-ins?</h2>
               
  
<p>One of the main design points of the Eclipse Platform is that it is extremely 
  extensible. Another is that it is uniform. The Eclipse plug-in model is key 
  in satisfying both of these goals. A plug-in is a piece of functionality which 
  can be added to the Platform. Tools or applications are constructed by creating 
  one or more plug-ins. How tools or applications are factored into plug-ins depends 
  on the nature of the tool or application. </p>
<p>The Eclipse Platform itself, for example, is made up entirely of plug-ins: 
  some 50 or so in all. Even the runtime which manages plug-ins, is itself a plug-in! 
  Plug-ins interact via well defined API's. Since everything is a plug-in and 
  plug-ins interact via public interfaces, all plug-ins are equal in the system. 
  There are no plug-ins which get special treatment or privileges. For example, 
  the Workbench UI is a plug-in which presents the resource model defined by the 
  Resources plug-in. Since the Workbench accesses the Resources plug-in only via 
  API, all other plug-ins have exactly the same opportunities for manipulating 
  resources.</p>
<p>It follows from this, that capabilities are added to the Platform incrementally, 
  by adding plug-ins. Each new plug-in ties into the API of existing plug-ins 
  and provides new functionality. Still other plug-ins then build on the API of 
  these new plug-ins to add still more functionality to the Platform. And so on...</p>
               
  
<p>Another design point that makes Eclipse extremely extensible is its policy 
  of lazy plug-in activation. Only those plug-ins with code that is actually being 
  used are activated. Lazy activation is key to supporting a large base of installed 
  plug-ins, only some of which are needed in any given user session. Until a plug-in's 
  code is loaded, it has a negligible memory footprint and impact on start up 
  time.</p>
<h2>What is a plug-in?</h2>
<p>Fundamentally, plug-ins are defined by an XML <em>manifest file</em> called 
  <code><strong>plugin.xml</strong></code>. An example plug-in manifest is shown 
  below. </p>
               
<blockquote> 
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plugin
    id="com.example.myplugin"
    name="My Plugin"
    version="2.0.0"
    provider-name="Example Plug-ins Inc."&gt;<br>&lt;/plugin&gt;
</pre>
</blockquote>
<p>Each plug-in is contained in a file system directory or at a base URL on a 
  server, with a plug-in manifest file (as seen above) and anything else it needs. 
</p>
<p>A typical plug-in consists of Java code in a JAR library, some read-only files, 
  and other resources such as images, web templates, message catalogs, native 
  code libraries, translation files, etc. Most plug-ins contribute executable 
  code though not all. Documentation plug-ins, for example, contribute online 
  help in the form of HTML pages. If a plug-in does contain code it must either 
  be written in Java or be callable from Java. </p>
<p>The above plug-in example is very simple. The following sections show how the 
  following elements of the plug-in architecture are used to round out the specification 
  of a plug-in.</p>
<ul>
  <li><b>Libraries</b> define the location of executable code. </li>
  <li><b>Prerequisites</b> define dependencies between plug-ins. </li>
  <li><b>Extension points</b> allow other plug-ins to contribute information in 
    a well-defined manner. </li>
  <li><b>Extensions</b> contribute information to the extension points of other 
    plug-ins. </li>
  <li><b>Fragments</b> allow a plug-in to be extended without the need to modify 
    anything related to the existing plug-in. </li>
</ul>
<h2>What is a Library?</h2>
<p>The first thing you are likely to want to do with a plug-in is define the location 
  of the plug-in's executable code and/or resources. <code><strong>library</strong></code> 
  entries in plugin.xml (see example below) describe the shape of these contributions. 
</p>
<blockquote>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plugin
    id="com.example.myplugin"
    name="My Plugin"
    version="2.0.0"
    provider-name="Example Plug-ins Inc."&gt;

  <strong>&lt;runtime&gt;
    &lt;library name="mylibrary.jar" type=&quot;code&quot;&gt;
      &lt;export name="*"/&gt;
    &lt;/library&gt;
  &lt;/runtime&gt;
</strong>
&lt;/plugin&gt;
</pre>
</blockquote>
<p><code><strong>library</strong></code> elements specify a portion of the plug-in's 
  local classpath. Each plug-in has two classpaths: one for code libraries and 
  one for resource libraries. Correspondingly, <code><strong>library</strong></code> 
  elements have a type attribute whose value is either <code><strong>code</strong></code> 
  or <code><strong>resource</strong></code> (<code><strong>code</strong></code> 
  is the default). Code libraries contain Java class files as well as any associated 
  resources. There is no need to artificially separate resources from the code 
  as code libraries can contain both. Libraries defined as type <code><strong>resource</strong></code> 
  on the other hand, can contain only resources (properties files, images).</p>
<p>The distinction allows the classloaders to ignore resource libraries while 
  loading classes, as they are guaranteed to contain only resources (e.g., translated 
  properties files). This translates into performance improvements as there are 
  fewer places to look for classes. Note that both the code and resource libraries 
  are consulted when loading resources.</p>
<p>Each <strong><code>library</code></strong> element identifies a files system 
  location (directory or jar file) which contains the code and/or resources. The 
  path specified is relative to the plug-in's file system directory and cannot 
  resolve to a location outside the scope of the plug-in (for example, &quot;../../foo.jar&quot; 
  is not allowed). </p>
<p>By default, everything in a code library is considered private (i.e., known 
  only within the scope of the plug-in). Portions of a library are made visible 
  outside its containing plug-in using the <strong><code>export</code></strong> 
  sub-element. Plug-ins can export some, all or none of their libraries by specifying 
  patterns in the name attribute of the <strong><code>export</code></strong> tag. 
</p>
<p>A <strong><code>library</code></strong> entry contained in our example plug-in, 
  <code>com.example.myplugin</code> is shown in the snippet above. It shows a 
  code library called &quot;mylibrary.jar&quot; which is exported in total.</p>
<h2>What is a Plug-in Prerequisite?</h2>
<p>Plug-ins must declare their dependencies on other plug-ins using a <strong><code>requires</code></strong> 
  element in their plug-in manifest file. Typically dependencies arise from inter-plug-in 
  class references. If a plug-in A requires plug-in B, plug-in B is said to be 
  a prerequisite of plug-in A. Continuing our example, the manifest below shows 
  the plugin.xml expressing a dependency on <code>com.example.anotherplugin</code>.</p>
<blockquote> 
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plugin
    id="com.example.myplugin"
    name="My Plugin"
	 version="2.0.0"
    provider-name="Example Plug-ins Inc."&gt;<br>
  <strong>&lt;requires&gt;
    &lt;import plugin="com.example.anotherplugin"
        version=&quot;2.1.3&quot;
        match=&quot;equivalent&quot;/&gt;
  &lt;/requires&gt;
</strong>
  &lt;runtime&gt;
    &lt;library name="mylibrary.jar" type=&quot;code&quot;&gt;
      &lt;export name="*"/&gt;
    &lt;/library&gt;
  &lt;/runtime&gt;

&lt;/plugin&gt;</pre>
</blockquote>
<p>In this example, <code>com.example.myplugin</code> (My Plugin) can access any 
  of the classes in <code>com.example.anotherplugin</code> (Another Plugin) which 
  are explicitly exported in its library statements. </p>
<p>Notice that the <strong><code>import</code></strong> statement is qualified 
  by a version number and matching rule. Versions refine the dependencies between 
  plugins and help the runtime choose between different installations of the same 
  plug-in. In general the runtime picks the most recent version which matches 
  given the matching rule. Eclipse version numbers are a four part string of the 
  form <strong><code>major.minor.service.tag</code></strong>. Versions are compared 
  using one of four matching rules.</p>
<dl>
  <dl>
    <dt><b>perfect</b></dt>
    <dd>All four components of the version must match.</dd>
    <dt><b>equivalent</b></dt>
    <dd>major and minor must match and others must sort after</dd>
    <dt><b>compatible</b> (default)</dt>
    <dd>major must match and others must sort after</dd>
    <dt><b>greaterOrEqual</b></dt>
    <dd>Any version which is a perfect match or sorts lexographically after</dd>
  </dl>
</dl>
<p>Plug-in dependencies are transitive. That is, if Another Plugin requires some 
  plug-in, say Final Plugin, then My Plugin will not be enabled unless both Another 
  Plugin and Final Plugin are present. This is easy to see since Another Plugin 
  would be disabled if its prerequisites are not met (e.g., Final Plugin is not 
  present). Similarly, My Plugin would also be disabled if its prerequisite, Another 
  Plugin, is not present. Under no circumstances are circular dependencies permitted. 
  Any plug-in involved in a cycle will be disabled at runtime.</p>
<p>Class visibility through the dependency chain is not transitive unless explicitly 
  stated. That is, My Plugin cannot see the classes in Final Plugin unless Another 
  Plugin explicitly re-exports its import of Final Plugin. This effectively encapsulates 
  the implementation of Another Plugin. Where transitivity is required, the <code><strong>export</strong></code> 
  attribute of the <strong><code>import</code></strong> tag is used to re-export 
  the classes exported by imported plug-ins. (try saying that a few times quickly!). 
  For example, </p>
 <blockquote>
  <pre>    &lt;import plugin="com.example.finalplugin" export=&quot;true&quot;/&gt;
</pre>
</blockquote>
<p>Finally, plug-in prerequisite statements can be made optional by adding the 
  <strong><code>optional=&quot;true&quot;</code></strong> attribute to the <strong><code>import</code></strong> 
  tag (see below for an example). Marking an import as <code>optional</code> simply 
  states that if the specified plug-in is not found at runtime, the dependent 
  plug-in should be left enabled. This is used when a plug-in can be used in many 
  scenarios or it is reasonable to operate with reduced function. It allows the 
  creation of minimal installs that cover functional subsets. Authors of plug-ins 
  using optional prerequisites should take special care to avoid or handle the 
  ClassNotFoundExceptions which will occur when the optional plug-in is not present.</p>
<pre>    &lt;import plugin="com.example.finalplugin" optional=&quot;true&quot;/&gt;
</pre>
<h2>What are Extensions and Extension Points?</h2>
<p><em>Extension points</em> are a mechanism used by plug-ins to indicate they 
  are willing to accept contributions from other plug-ins. An <em>extension</em> 
  is a plug-in's way of contributing information to these extension points. For 
  example, a UI plug-in might expose an extension point for menu actions. A plug-in 
  wishing to contribute an action to the UI would define an extension for the 
  UI's menu action extension point.</p>
<p>Extension points have a globally unique id constructed from the defining plug-in 
  id and a simple id specified in the extension point itself. The example below 
  is from the <code>org.eclipse.ui</code> plug-in. The full identifier of the 
  extension point is therefore <code>org.eclipse.ui.actionSets</code>. All extension 
  points have this relatively simple form.</p>
<blockquote>
  <pre>  &lt;extension-point name="Action Sets" id="actionSets"/&gt;</pre>
</blockquote>
<p>The exact form of extensions is defined by the plug-in which defines the extension 
  point being extended. In the above example, the UI plug-in specifies what information 
  is needed to define the menu action as well as the form of that information. 
  For example, the UI needs a class it can instantiate and run when the menu entry 
  is selected. The type characteristics (e.g., superclass, interfaces) of the 
  class are also defined by the extension point itself. Such an extension is called 
  an <em>executable extension</em>. The snippet below shows an example extension.</p>
<blockquote> 
  <pre>  &lt;extension
      point=&quot;org.eclipse.ui.actionSets&quot;&gt;
    &lt;actionSet
        label=&quot;Example&quot;
        visible=&quot;false&quot;
        id=&quot;com.example.actions&quot;&gt;
      &lt;action
          id=&quot;com.example.action1&quot;
          class=&quot;com.example.CoolAction&quot;
          icon=&quot;icons/action1.gif&quot;
          helpContextId=&quot;action1_context&quot;
          label=&quot;Action1&quot;
      &lt;/action&gt;
    &lt;/actionSet&gt;
  &lt;/extension&gt;
</pre>
  </blockquote>
<p>A plug-in can define any number of extension points and extensions. Further, 
  any given extension point may be extended by any number of extensions (including 
  0). Extensions can extend extension points defined in their own plug-in or in 
  others. It follows, therefore, that extension points can accept extensions from 
  their own plug-in or other plug-ins. </p>
<p>Extending an extension point does not imply a dependency relationship. Rather, 
  it is a statement that if there is an extension point with the given id (point 
  attribute in the <strong><code>extension</code></strong> tag), add the given 
  extension. Otherwise, do nothing.</p>
<h4></h4>
<h2>What is a Fragment?</h2>
<p>Fragments allow optional functionality/content to be <strong>added</strong> 
  to existing plug-ins. For example, the base Eclipse contains only English messages. 
  Fragments are used to add message catalogs containing other languages (e.g., 
  French, Italian) without modifying the existing plug-ins. Note that fragments 
  can only add function/content to plug-ins. They cannot override that which the 
  plug-in already contains. Fragments are added to the base plug-in in no particular 
  order and fragments for missing plug-ins are ignored.</p>
<p>It is not surprising to find that fragments are very similar to plug-ins; they 
  are defined with a single manifest file, called <strong><code>fragment.xml</code></strong>, 
  in a file system directory which contains everything the fragment needs. Each 
  fragment must be associated with a particular plug-in. And any given plug-in 
  can have any number of fragments associated with it. </p>
<p>Further, fragments can contribute libraries, prerequisites, extension points 
  or extensions using standard syntax. These contributions are seamlessly merged 
  into the fragment's base plug-in. That is, extensions and extension points from 
  a fragment appear to come from/be part of (respectively) the base plug-in, libraries 
  are put on the base plug-in's classpath and prerequisites contribute to the 
  plug-in's prerequisite chain.</p>
<p>Below, is an example of a simple NL fragment for <code>com.example.myplugin</code>.</p>
<blockquote> 
  <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;fragment
    id="com.example.myplugin.addon1"  	  
    name="Example Add-on 1 Fragment"
    version="2.0.2"
    provider-name="Eclipse.org"
    plugin-id="com.example.myplugin"
    plugin-version="2.0.0"
    match="compatible"&gt;

  &lt;runtime&gt;<br>    &lt;library name="nl1.jar"/&gt;<br>  &lt;/runtime&gt;<br>&lt;/fragment&gt;
</pre>
</blockquote>
<p>This fragment contributes additional jars which contain translations of the 
  messages used by the plug-in itself. In this case the jar contains files named 
  according to the standard Java locale-based lookup strategy (e.g., message_en_US.properties, 
  message_jp_JP.properties). Since the jars are added to the plug-in's classpath, 
  the plug-in classloader will find these resources automatically. </p>
<h2>The Plug-in Model at Runtime</h2>
<p>All of the information we have discussed to date has dealt with physical plug-in 
  information stored in the Eclipse environment. We will now talk about the <em>runtime</em> 
  version of all this plug-in information.</p>
<h4>The Plug-in Registry</h4>
<p>When the Eclipse Platform starts, it first discovers all available plug-ins 
  and fragments. The install/update component of Eclipse and a user-defineable 
  plug-in path are used to determine directories where plug-ins and fragments 
  can be found. Each plug-in/fragment directory may contain exactly one manifest 
  file named <code>plugin.xml </code>or <code>fragment.xml</code>. If a directory 
  contains both files, only the <code>plugin.xml</code> file is used.
</p>
<p> Once the discovery is completed, the platform parses the discovered manifest 
  files and builds a <em>plug-in registry</em>. Manifests which cannot be loaded 
  are skipped and the failure is noted in the platform's log (typically under 
  the <code>&lt;workspace&gt;/.metadata</code> directory). The registry is then 
  <em>resolved.</em> That is, it is examined to ensure the structure is useful 
  and sane, and its structures are cross linked. Resolution includes the following 
  steps:</p>
<ul>
  <li>each element in the list (plug-in, fragment, extension point, etc.) must 
    have all of the required fields. Required fields are those fields with the 
    tag &quot;#REQUIRED&quot; in the appendix &quot;DTD's for plugin.xml and fragment.xml".</li>
  <li>each fragment must be associated with a plug-in</li>
  <li>each plug-in must have access to any prerequisite plug-ins (after version 
    compatibility matching) unless a prerequisite has been denoted as <code>optional</code></li>
  <li>each extension must be matched with an extension point</li>
</ul>
<p>An error message is logged if any problems are encountered and the offending 
  element is removed from the plug-in registry. This allows Eclipse to continue 
  running even if there are minor problems. The resulting plug-in registry is 
  available via the <code>org.eclipse.core.runtime</code> plug-in's API. The whole 
  plug-in registry is available through <code>IPluginRegistry</code> and individual 
  plug-ins can be examined with <code>IPluginDescriptor</code>.</p>
<p>Because these plug-ins define the running Eclipse, additions, deletions or 
  modifications of plug-ins are not detected after start-up. Eclipse must be shut 
  down and restarted to detect these changes.</p>
<h4>Plug-in Activation</h4>
<p>When Eclipse starts up, only those plug-ins needed to build the plug-in registry 
  and get things started are activated. All other plug-ins (the vast majority 
  of plug-ins) remain dormant. When something happens causing the code within 
  a plug-in to be loaded, that particular plug-in is activated. That is, classloading 
  is the only trigger for plug-in activation. Plug-ins are only activated if the 
  class loaded comes from the plug-in's local classpath (i.e., one of its libraries). 
  Loading classes from a prerequisite does not count. This is the basis for Eclipse's 
  lazy plug-in activation policy.</p>
<p>Many things can happen without activating a plug-in. In particular, </p>
<ul>
  <li>resources can be loaded (either from a resource or code library) </li>
  <li>plug-in classloaders can ask other classloaders to load classes. </li>
  <li>extensions and extension points can be examined without having to activate 
    the plug-in that contains the extension. </li>
</ul>
<p>Once a plug-in is activated it remains active until Eclipse shuts down. When 
  Eclipse does shut down, all plug-ins are shut down in a dependents-first order. 
  For example, if plug-in A requires plug-in B, then plug-in A will be shut down 
  before plug-in B.</p>
<h4>Plug-in Classloading</h4>
<p>Libraries define the local classpath of a plug-in. Each library entry translates 
  into an entry on the classpath of the plug-in's classloader. Earlier we discussed 
  the concept of a <strong><code>code</code></strong> vs. a <strong><code>resource</code></strong> 
  library. Resource libraries are loaded by a resource loader and do not figure 
  into the strict classloading model.</p>
<p>Classloading in Eclipse follows the P-S-P model. That is, Parent-Self-Prerequisites. 
</p>
<dl> 
  <dl>
    <dt><b>Parent</b> </dt>
    <dd>Each plug-in classloader has the Eclipse boot plug-in's classloader as 
      its parent. The boot plug-in loader's parent is the system classloader. 
      Note that the standard Java AppClassloader (the one used to load the class 
      containing main()) is not added to the classloading chain. As a result, 
      the jars added to the JVM's classpath are ignored. Jars added to the JVM's 
      bootclasspath are part of the system classloader and are considered during 
      plug-in classloading.</dd>
    <dt><b>Self</b></dt>
    <dd>Self considers the libraries defined as part of this plug-in. All code 
      libraries contributed by fragments to this plug-in are also considered. 
      Libraries contributed by fragments appear after those contributed in the 
      plug-in manifest (in indeterminant order). Libraries from the same manifest 
      appear on the class path in the same order in which they were declared.</dd>
    <dt><b>Prerequisites</b></dt>
    <dd>Finally the exported libraries of the plug-in's prerequisites are considered. 
      Prerequisites are queried in the order in which they were declared with 
      the exception of the runtime plugin (<code>org.eclipse.core.runtime</code>). 
      All plug-ins automatically have the Eclipse runtime plug-in (<code>org.eclipse.core.runtime</code>) 
      added to their prerequisite list as the first prerequisite. All imports 
      of the runtime plug-in are ignored. 
      <p> Note that prerequisite consultation is transitive. When locating a class, 
        a prerequisite plug-in will follow the same (though optimized) P-S-P model. 
        Since all plug-in classloaders have the same parent, prerequisite loaders 
        need not look there. Similarly, plug-ins which occur repeatedly in the 
        transitive closure of the prerequisite graph are consulted at most once. 
        Finally, prerequisite re-exporting rules are followed as described above.</p>
    </dd>
  </dl>
</dl>
<h4>Plug-in Data</h4>
                               
      
<p>The Eclipse Platform makes certain assumptions about the physical structure 
  of a plug-in. Each plug-in or fragment is typically stored in a separate directory 
  under a directory named <strong><code>plugins</code></strong> under your Eclipse 
  install directory. The name of this directory is usually the same as the plug-in's 
  id (though it may have the version number appended to it). In addition to the 
  <code>plugin.xml</code> or <strong><code>fragment.xml</code></strong> file, 
  there may be any number of folders under the plug-in's root folder.</p>
<p>Since Eclipse can be run on a wide range of machine configurations (i.e., operating 
  system, window system) it needs a way of managing different forms of the same 
  data (e.g., shared libraries). Eclipse provides four variables for use in library 
  statements which resolve to parts of the current machine configuration.</p>
<dl> 
  <dl>
    <dt><b>os</b></dt>
    <dd>The operating system on which Eclipse is currently running (e.g., win32, 
      linux, solaris)</dd>
    <dt><b>ws</b></dt>
    <dd>The window system being used for the Eclipse UI (e.g., win32, motif, gtk)</dd>
    <dt><b>arch</b></dt>
    <dd>The type of processor in the machine (e.g., x86, ppc, sparc)</dd>
    <dt><b>nl</b></dt>
    <dd>The current locale (e.g., en_CA, jp_JP)</dd>
  </dl>
</dl>
<p>So, for example, if your plug-in uses windowing system-specific features, it 
  may be necessary to provide a different library for each configuration. Using<em> 
  </em><strong><code>$ws$/&lt;library name&gt;</code></strong> in your plug-in 
  manifest file directs Eclipse to look for the library in a window system directory 
  with the same name as the current window system. The <code>org.eclipse.swt</code> 
  plug-in uses this mechanism as follows:</p>
<blockquote>
  <pre>  &lt;runtime&gt;
    &lt;library name=&quot;$ws$/swt.jar&quot;&gt;
      &lt;export name=&quot;*&quot;/&gt;
    &lt;/library&gt;
  &lt;/runtime&gt;
</pre>
</blockquote>
<p>The SWT plug-in has a series of directories of the form <code>ws/&lt;windowing 
  system&gt;/</code>(e.g., <code>ws/win32</code>, <code>ws/gtk</code>, <code>ws/motif</code>). 
  Each of these directories contains a different version of <code>swt.jar</code>. 
  If you are working in an Eclipse environment in a win32 windowing system, the 
  library name <code>$ws$/swt.jar</code> will match <code>ws/win32/swt.jar</code>. 
  Note that in practice any given Eclipse install will have only one <code>swt.jar</code> 
  (the one that matches the install). The jars are actually contributed by window 
  system-specific fragments. This allows the common part of a plug-in to be put 
  in the plug-in and have only the window system code in a fragment.</p>
<h2>Summary</h2>
<p>This article has set the stage for plug-ins: defining what they are, why they 
  are important and concepts related to them. The appendices give a more formal 
  definition of the XML used to define plug-ins, fragments, extension points, 
  etc. A companion article, &quot;How Does the Platform Tick?&quot; builds on 
  the concepts discussed here and gives a more detailed look into how plug-ins 
  work. </p>
<p>The following appendices are included for easy reference and are up-to-date 
  as of the time of the writing of this document. The Platform Plug-in Developers 
  Guide contains the most up-to-date versions of these documents for each Eclipse 
  release.</p>
<h2>Appendix: DTDs for plugin.xml and fragment.xml</h2>
<div class=Section1>
  <pre>&lt;?xml encoding=&quot;US-ASCII&quot;?&gt;</pre>
  <pre><p>
&lt;!ELEMENT plugin (requires?, runtime?, extension-point*, extension*)&gt;
&lt;!ATTLIST plugin
 name                CDATA #REQUIRED
 id                  CDATA #REQUIRED
 version             CDATA #REQUIRED
 provider-name       CDATA #IMPLIED
 class               CDATA #IMPLIED
&gt;</p></pre>
  <pre><p>
&lt;!ELEMENT fragment (requires?, runtime?, extension-point*, extension*)&gt;
&lt;!ATTLIST fragment
 name                CDATA #REQUIRED
 id                  CDATA #REQUIRED
 version             CDATA #REQUIRED
 provider-name       CDATA #IMPLIED
 plugin-id           CDATA #REQUIRED
 plugin-version      CDATA #REQUIRED
 match               (perfect | equivalent | compatible | greaterOrEqual) &quot;compatible&quot;
&gt;
</p></pre>
  <pre><p>
&lt;!ELEMENT requires (import+)&gt;
&lt;!ELEMENT import EMPTY&gt;
&lt;!ATTLIST import
 plugin              CDATA #REQUIRED
 version             CDATA #IMPLIED
 match               (perfect | equivalent | compatible | greaterOrEqual) &quot;compatible&quot;
 export              (true | false) &quot;false&quot;
 optional            (true | false) &quot;false&quot;
&gt;
</p></pre>
  <pre><p>
&lt;!ELEMENT runtime library+)&gt;</p></pre>
  <pre><p>
&lt;!ELEMENT library (export*, packages?)&gt;
&lt;!ATTLIST library
 name                CDATA #REQUIRED
 type                (code | resource) &quot;code&quot;
&gt;
</p></pre>
  <pre><p>
&lt;!ELEMENT export EMPTY&gt;
&lt;!ATTLIST export
 name                CDATA #REQUIRED
&gt;
</p></pre>
  <pre>&lt;!ELEMENT packages EMPTY&gt;
&lt;!ATTLIST packages
 prefixes            CDATA #REQUIRED
&gt;</pre>
  <pre><p>
&lt;!ELEMENT extension-point EMPTY&gt;
&lt;!ATTLIST extension-point
 name                CDATA #REQUIRED
 id                  CDATA #REQUIRED
 schema              CDATA #IMPLIED
&gt;
</p></pre>
  <pre><p>
&lt;!ELEMENT extension ANY&gt;
&lt;!ATTLIST extension
 point               CDATA #REQUIRED
 name                CDATA #IMPLIED
 id                  CDATA #IMPLIED
&gt;</p></pre>
  <p><a href="hglegal.htm"><img src="../../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="250" height="12"></a></p>
</div>
<p>&nbsp;</p>
                                       
        
<h2>Appendix: Eclipse Platform Plug-in Manifest</h2>
<div class=Section1> 
  <h1>Eclipse platform plug-in manifest</h1>
  <p class=MsoNormal><span style='font-size:10.0pt'>Version 2.1 - Last revised 
    March 17, 2003</span></p>
  <p>The manifest markup definitions below make use of various naming tokens and 
    identifiers. To eliminate ambiguity, here are some production rules for these 
    [are referenced in text below]. In general, all identifiers are case-sensitive. 
  </p>
  <pre>SimpleToken := sequence of characters from ('a-z','A-Z','0-9')&nbsp;
ComposedToken := SimpleToken | (SimpleToken '.' ComposedToken)&nbsp;
JavaClassName := ComposedToken&nbsp;
PlugInId := ComposedToken
PlugInPrereq := PlugInId | 'export' PlugInId&nbsp;
ExtensionId := SimpleToken&nbsp;
ExtensionPointId := SimpleToken&nbsp;
ExtensionPointReference := ExtensionPointID | (PlugInId '.' ExtensionPointId)</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    remainder of this section describes the plugin.xml file structure as a series 
    of DTD fragments. File <a href="plugin_dtd.html">plugin.dtd</a> presents the 
    DTD definition in its entirety. </p>
  <pre>&lt;?xml encoding=&quot;US-ASCII&quot;?&gt;&nbsp;
&lt;!ELEMENT plugin (requires?, runtime?, extension-point*, extension*)&gt;&nbsp;
&lt;!ATTLIST plugin&nbsp;
&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&nbsp; id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&nbsp; version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&nbsp; provider-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED
&nbsp; class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED&nbsp;
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;plugin&gt; element defines the body of the manifest. It optionally contains 
    definitions for the plug-in runtime, definitions of other plug-ins required 
    by this one, declarations of any new extension points being introduced by 
    the plug-in, as well as configuration of functional extensions (configured 
    into extension points defined by other plug-ins, or introduced by this plug-in). 
    &lt;plugin&gt; attributes are as follows: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>name</b> - user displayable 
      (translatable) name for the plug-in</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>id</b> - unique identifier 
      for the plug-in.</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l2 level2 lfo3;tab-stops:list 1.0in'>To minimize potential 
        for naming collisions, the identifier should be derived from the internet 
        domain id of the supplying provider (reversing the domain name tokens 
        and appending additional name tokens separated by dot [.]). For example, 
        provider ibm.com could define plug-in identifier com.ibm.db2</li>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l2 level2 lfo3;tab-stops:list 1.0in'>[production rule: PlugInId]</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>version </b>- plug-in version 
      number. See org.eclipse.core.runtime.PluginVersionIdentifier for details. 
      Plug-in version format is <b>major.minor.service.qualifier</b>. Change in 
      the major component is interpreted as an incompatible version change. Change 
      in the minor component is interpreted as a compatible version change. Change 
      in the service component is interpreted as <i>cumulative</i> service applied 
      to the minor version.<span style="mso-spacerun:
     yes">&nbsp; </span>Change in the qualifier component is interpreted as different 
      source code control version of the same component.</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>provider-name</b> <b>-</b> 
      user-displayable name of the provider supplying the plug-in.</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>class - </b>name of the plug-in 
      class for this plug-in. The class must be a subclass of org.eclipse.core.runtime.Plugin.</li>
  </ul>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    XML DTD construction rule <tt><i><span style='font-size:10.0pt;font-family:
"Courier New"'>element</span></i></tt><tt><span style='font-size:10.0pt;
font-family:"Courier New"'>*</span></tt> means zero or more occurrences of the 
    element; <tt><i><span style='font-size:10.0pt;font-family:"Courier New"'>element</span></i></tt><tt><span
style='font-size:10.0pt;font-family:"Courier New"'>?</span></tt> means zero or 
    one occurrence of the element; and <tt><i><span style='font-size:10.0pt;
font-family:"Courier New"'>element</span></i></tt><tt><span style='font-size:
10.0pt;font-family:"Courier New"'>+</span></tt> (used below) means one or more 
    occurrences of the element. Based on the &lt;plugin&gt; definition above, 
    this means, for example, that a plug-in containing only a run-time definition 
    and no extension point declarations or extension configurations is valid (for 
    example, common libraries that other plug-ins depend on). Similarly, a plug-in 
    containing only extension configurations and no runtime or extension points 
    of its own is also valid (for example, configuring classes delivered in other 
    plug-ins into extension points declared in other plug-ins). </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;requires&gt; section of the manifest declares any dependencies on other 
    plug-ins. </p>
  <pre>&lt;!ELEMENT requires (import+)&gt;
&lt;!ELEMENT import EMPTY&gt;
&lt;!ATTLIST import
&nbsp;plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED
&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED
 match<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(perfect | equivalent | compatible | greaterOrEqual) &quot;compatible&quot;
&nbsp;export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (true | false) &quot;false&quot;
&nbsp;optional&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (true | false) &quot;false&quot;
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Each 
    dependency is specified using an &lt;import&gt; element. It contains the following 
    attributes: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><b>plugin</b> - identifier of 
      the required plug-in</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><b>version</b> - optional version 
      specification</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><b>match</b> - version matching 
      rule. Ignored if version attribute is not specified. Determines whether 
      the dependency is satisfied only with a plug-in<span
     style="mso-spacerun: yes">&nbsp; </span>that has this exact<span
     style="mso-spacerun: yes">&nbsp; </span>specified version, with a plug-in 
      that has a service or qualifier more recent than this one, with any compatible 
      version (including a more recent minor version of the plug-in) or with any 
      more recent version of this plug-in</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><b>export</b> - specifies whether 
      the dependent plug-in classes are made visible (are (re)exported) to users 
      of this plug-in. By default, dependent classes are not exported (are not 
      made visible)</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><b>optional</b> - specifies 
      whether or not this dependency will be strictly enforced.<span
     style="mso-spacerun: yes">&nbsp; </span>If set to &lt;true&gt; and this dependency 
      cannot be satisfied, the dependency will be ignored</li>
  </ul>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><a
name=runtime></a>The &lt;runtime&gt; section of the manifest contains a definition 
    of one or more libraries that make up the plug-in runtime. The referenced 
    libraries are used by the platform execution mechanisms (the plug-in class 
    loader) to load and execute the correct code required by the plug-in. </p>
  <pre>&lt;!ELEMENT runtime (library+)&gt;&nbsp;
&lt;!ELEMENT library (export*, packages?)&gt;
&lt;!ATTLIST library&nbsp;
  name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
<span style="mso-spacerun: yes">&nbsp; </span>type<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(code | resource) &quot;code&quot;
&gt;
&lt;!ELEMENT export EMPTY&gt;&nbsp;
&lt;!ATTLIST export
&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&gt;
&lt;!ELEMENT packages EMPTY&gt;
&lt;!ATTLIST packages
  prefixes           CDATA #REQUIRED
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;runtime&gt; element has no attributes. </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;library&gt; elements collectively define the plug-in runtime. At least 
    one &lt;library&gt; must be specified. Each &lt;library&gt; element has the 
    following attributes: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo9;tab-stops:list .5in'><b>name - </b>string reference 
      to a library file or directory containing classes (relative to the plug-in 
      install directory). Directory references must contain trailing file separator.</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo9;tab-stops:list .5in'><b>type</b> - specifies whether 
      this library contains executable code (&lt;code&gt;) or just resources.<span style="mso-spacerun: yes">&nbsp; 
      </span>If the library is of type &lt;code&gt; accessing anything in this 
      library will cause activation of the plug-in.<span style="mso-spacerun: yes">&nbsp; 
      </span>Accessing a &lt;resource&gt; will not cause plug-in activation (a 
      potential for significant performance improvement).<span style="mso-spacerun: yes">&nbsp; 
      </span>It should be noted that specifying a library of type &lt;code&gt; 
      allows it to contain both code and resources.<span style="mso-spacerun: yes">&nbsp; 
      </span>But specifying a library of type &lt;resource&gt; assumes it will 
      only be used for resources.</li>
  </ul>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Each 
    &lt;library&gt; element can specify which portion of the library should be 
    exported. The export rules are specified as a set of export masks. By default 
    (no export rules specified), the library is considered to be private. The 
    &lt;export&gt; elements have the following attributes: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo12;tab-stops:list .5in'><b>name - s</b>pecifies the 
      export mask. Valid values are:</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l5 level2 lfo12;tab-stops:list 1.0in'><b>*</b> - indicates 
        all contents of library are exported (public)</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo12;tab-stops:list .5in'><b>package-name</b></li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l5 level2 lfo12;tab-stops:list 1.0in'><b>* - </b>indicates 
        all classes in the specified package are exported. The matching rules 
        are the same as in the Java import statement.</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo12;tab-stops:list .5in'><b>class-name - </b>fully qualified 
      java class name</li>
  </ul>
  Each library can also specify the package prefixes. These are used to enhance 
  the classloading performance for the plug-in and/or fragment. If the &lt;packages&gt; 
  element is not specified, then by default the classloading enhancements are 
  not used. The &lt;packages&gt; element has the following attribute: 
  <p></p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo12;tab-stops:list .5in'><b>prefixes - </b>a comma-separated 
      list of package prefixes for the runtime library</li>
  </ul>
  More detailed information about package prefixes can be found <a href="plugin_package_prefixes.html">here</a>. 
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    platform's architecture is based on the notion of configurable extension points. 
    The platform itself predefines a set of extension points that cover the task 
    of extending the platform and desktop (for example, adding menu actions, contributing 
    embedded editor). In addition to the predefined extension points, each supplied 
    plug-in can declare additional extension points. By declaring an extension 
    point the plug-in is essentially advertising the ability to configure the 
    plug-in function with externally supplied extensions. For example, the Page 
    Builder plug-in may declare an extension point for adding new Design Time 
    Controls (DTCs) into its builder palette. This means that the Page Builder 
    has defined an architecture for what it means to be a DTC and has implemented 
    the code that looks for DTC extensions that have been configured into the 
    extension points. </p>
  <pre>&lt;!ELEMENT extension-point EMPTY&gt;&nbsp;&nbsp;
&lt;!ATTLIST extension-point&nbsp;
&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&nbsp; id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; schema&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED&nbsp;
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;extension-point&gt; element has the following attributes: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in'><b>name - </b>user-displayable 
      (translatable) name for the extension point</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in'><b>id - </b>simple id token, 
      unique within this plug-in. The token cannot contain dot (.) or whitespace.</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l3 level2 lfo15;tab-stops:list 1.0in'>[production rule: ExtensionPointId]</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo15;tab-stops:list .5in'><b>schema</b> - schema specification 
      for this extension point. The exact details are being defined as part of 
      the Plug-In Development Environment (PDE). The schema is currently not used 
      at runtime. The reference is a file name relative to the plug-in installation 
      location.</li>
  </ul>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Actual 
    extensions are configured into extension points (predefined, or newly declared 
    in this plug-in) in the &lt;extension&gt; section. The configuration information 
    is specified as well-formed XML contained between the &lt;extension&gt; and 
    &lt;/extension&gt; tags. The platform does not specify the actual form of 
    the configuration markup (other than requiring it to be well-formed XML). 
    The markup is defined by the supplier of the plug-in that declared the extension 
    point. The platform does not actually interpret the configuration markup. 
    It simply passes the configuration information to the plug-in as part of the 
    extension point processing (at the time the extension point logic queries 
    all of its configured extensions). </p>
  <pre>&lt;!ELEMENT extension ANY&gt;&nbsp;
&lt;!ATTLIST extension&nbsp;
&nbsp; point&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED&nbsp;
&nbsp; id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED&nbsp;
&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #IMPLIED&nbsp;
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The 
    &lt;extension&gt; element has the following attributes: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo18;tab-stops:list .5in'><b>point - </b>reference to 
      an extension point being configured. The extension point can be one defined 
      in this plug-in or another plug-in</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l4 level2 lfo18;tab-stops:list 1.0in'>[production rule: ExtensionPointReference]</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo18;tab-stops:list .5in'><b>id - </b>optional identifier 
      for this extension point configuration instance. This is used by extension 
      points that need to uniquely identify (rather than just enumerate) the specific 
      configured extensions. The identifier is specified as a simple token unique 
      within the definition of the declaring plug-in. When used globally, the 
      extension identifier is qualified by the plug-in identifier</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l4 level2 lfo18;tab-stops:list 1.0in'>[production rule: ExtensionId]</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l4 level1 lfo18;tab-stops:list .5in'><b>name - </b>user-displayable 
      (translatable) name for the extension</li>
  </ul>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>Important:</b> 
    The content of the &lt;extension&gt; element is declared using the <tt><span
style='font-size:10.0pt;font-family:"Courier New"'>ANY</span></tt> rule. This 
    means that any well-formed XML can be specified within the extension configuration 
    section (between &lt;extension&gt; and &lt;/extension&gt; tags). </p>
  <p></p>
  Fragments are used to increase the scope of a plug-in.<span style="mso-spacerun: yes">&nbsp; 
  </span>An example would be to incorporate data such as messages or labels in 
  another language.
  <p></p>
  <pre>&lt;?xml encoding=&quot;US-ASCII&quot;?&gt;&nbsp;
&lt;!ELEMENT fragment (requires?, runtime?, extension-point*, extension*)&gt;
&lt;!ATTLIST fragment
&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED
&nbsp; id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED
&nbsp; version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CDATA #REQUIRED
&nbsp; provider-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDATA #IMPLIED
<span style="mso-spacerun: yes">&nbsp; </span>plugin-id<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CDATA #REQUIRED
<span style="mso-spacerun: yes">&nbsp; </span>plugin-version<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CDATA #REQUIRED
<span style="mso-spacerun: yes">&nbsp; </span>match<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(perfect | equivalent | compatible | greaterOrEqual) &quot;compatible&quot;
&gt;</pre>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Each 
    fragment must be associated with a specific plug-in. The associated plug-in 
    is identified with &lt;plugin-id&gt;, &lt;plugin-version&gt; and optionally, 
    &lt;match&gt;. Note that if this specification matches more than one plug-in, 
    the matching plug-in with the highest version number will be used.
  <p></p>
  The &lt;requires&gt;, &lt;runtime&gt;, &lt;extension-point&gt;, and &lt;extension&gt; 
  components of a fragment will be logically added to the matching plug-in.
  <p></p>
  <p class=MsoNormal style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>&lt;fragment&gt; 
    attributes are as follows: </p>
  <ul type=disc>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>name</b> - user displayable 
      (translatable) name for the fragment</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>id</b> - unique identifier 
      for the fragment.</li>
    <ul type=circle>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l2 level2 lfo3;tab-stops:list 1.0in'>To minimize potential 
        for naming collisions, the identifier should be derived from the id of 
        the associated plug-in in addition to something which identifies the scope 
        of this fragment.<span style="mso-spacerun: yes">&nbsp; </span>For example, 
        org.eclipse.core.runtime.nl1 could define a natural language fragment 
        for the org.eclipse.core.runtime plug-in</li>
      <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
      auto;mso-list:l2 level2 lfo3;tab-stops:list 1.0in'>[production rule: PlugInId]</li>
    </ul>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>version </b>- fragment version 
      number. See org.eclipse.core.runtime.PluginVersionIdentifier for details. 
      Fragment version format is the same as plug-in version format.</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>provider-name</b> <b>-</b> 
      user-displayable name of the provider supplying the fragment.</li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>plugin-</b><b
     style='mso-bidi-font-weight:normal'>id</b> - matches the id of the associated 
      plug-in<b style="mso-bidi-font-weight:normal"></b>
      <p></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>plugin-</b><b
     style='mso-bidi-font-weight:normal'>version</b> - matches the version of 
      the associated plug-in<b style="mso-bidi-font-weight:normal"></b>
      <p></p>
    </li>
    <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l2 level1 lfo3;tab-stops:list .5in'><b>match</b><span
     style='mso-bidi-font-weight:bold'> - the matching rule used to find an associated 
      plug-in using &lt;plugin-id&gt; and &lt;plugin-version&gt;.<span style="mso-spacerun: yes">&nbsp; 
      </span>See the definition of &lt;match&gt; in the &lt;requires&gt; clause 
      for complete details.</span>
      <p></p>
    </li>
  </ul>
  <p><a href="hglegal.htm"><img src="../../ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="250" height="12"></a></p>
</div>
<p>&nbsp;</p>
                                       
</body>
</html>
